using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Crypto.IO;

using System.IO;
using System;
using Snowflake.Data.Log;
using System.Security.Cryptography;
using System.Text;

namespace Snowflake.Data.Core.FileTransfer
{
    /// <summary>
    /// Helper class to encrypt and decrypt data
    /// </summary>
    class EncryptionProvider
    {
        private class CleanableCryptoStream : CryptoStream
        {
            private ICryptoTransform _transform;
            /// <summary>
            /// The cryptoStream to write to.
            /// </summary>
            private readonly Stream _stream;

            /// <summary>
            /// The IV generated by the encrypter.
            /// </summary>
            public byte[] IV { get ; }

            public CleanableCryptoStream(Stream cryptoStream, ICryptoTransform transform, CryptoStreamMode mode, byte[] iv)
            : base(cryptoStream, transform, mode)
            {
                _stream = cryptoStream;
                _transform = transform;
                IV = iv;
            }

            protected override void Dispose(bool disposing)
            {
                try
                {
                    base.Dispose(disposing);
                }
                catch (CryptographicException)
                {
                    // Make sure to close the inner stream if closing the cryptoStream fail
                    //https://stackoverflow.com/questions/41230836/dispose-a-cryptostream-after-it-has-thrown-a-cryptographicexception
                    //https://stackoverflow.com/questions/37137536/c-sharp-encryption-system-security-cryptography-cryptographicexception-at-crypto
                    //https://stackoverflow.com/questions/45401733/disposing-cryptostream-vs-disposing-underlying-stream
                    if (disposing)
                    {
                        _stream.Dispose();
                    }
                }

                if (disposing)
                {
                    _transform?.Dispose();
                    _transform = null;
                }
            }
        }

        /// <summary>
        /// The logger.
        /// </summary>
        private static readonly SFLogger Logger = SFLoggerFactory.GetLogger<EncryptionProvider>();

        /// <summary>
        /// The file key IV.
        /// </summary>
        private static byte[] fileKeyIV = initializeFileKeyIV();

        /// <summary>
        /// Generate a random IV used for this Encryption provider.
        /// </summary>
        /// <returns></returns>
        static byte[] initializeFileKeyIV()
        {
            var random = new SecureRandom();
            byte[] iv = new byte[16];
            random.NextBytes(iv);

            return iv;
        }


        /// <summary>
        /// Encrypt data and write it into a Memory stream.
        /// </summary>
        /// <param name="inputStream"></param>
        /// <param name="queryStageMasterKey"></param>
        /// <param name="iv"></param>
        /// <param name="encryptedFileKey"></param>
        /// <returns></returns>
        public MemoryStream Encrypt(
            Stream inputStream,
            string queryStageMasterKey,
            out string ivBase64,
            out string keyBase64)
        {

            byte[] decodedMasterKey = Convert.FromBase64String(queryStageMasterKey);
            int masterKeySize = decodedMasterKey.Length;
            Logger.Debug($"Master key size : {masterKeySize}");

            // Generate file key
            var random = new SecureRandom();
            byte[] unencryptedFileKey = new byte[masterKeySize];
            random.NextBytes(unencryptedFileKey);

            // Encrypt file key
            byte[] encryptedFileKey = encryptFileKey(unencryptedFileKey, decodedMasterKey);
            keyBase64 = Convert.ToBase64String(encryptedFileKey);

            // Encrypt data
            MemoryStream outStream = new MemoryStream();
            using (var cryptoStream = CreateCryptoStream(
                outStream, 
                unencryptedFileKey,
                null,
                true,
                CipherMode.CBC,
                PaddingMode.PKCS7, 
                true))
            {
                ivBase64 = Convert.ToBase64String(cryptoStream.IV);

                //Encrypt Data
                inputStream.CopyTo(cryptoStream);

                // Once data is encrypted, release the input stream
                inputStream.Dispose();
            }

            return outStream;
        }

        public MemoryStream Decrypt(Stream encryptedInput, string queryStageMasterKey, string ivBase64,  string keyBase64)
        {
            byte[] decodedMasterKey = Convert.FromBase64String(queryStageMasterKey);
            int masterKeySize = decodedMasterKey.Length;

            byte[] iv = Convert.FromBase64String(ivBase64);
            byte[] encryptedFileKey = Convert.FromBase64String(keyBase64);


            // Decrypt file key
            byte[] decryptedKey =  decryptFileKey(encryptedFileKey, fileKeyIV, decodedMasterKey);

            // Decrypt data
            MemoryStream outStream = new MemoryStream();
            using (var cryptoStream = CreateCryptoStream(
                outStream,
                decryptedKey,
                iv,
                false,
                CipherMode.CBC,
                PaddingMode.PKCS7,
                true))
            {
                //Encrypt Data
                encryptedInput.CopyTo(cryptoStream);

                // Once data are encrypted, release the input stream
                encryptedInput.Dispose();
            }

            return outStream;

        }

        /// <summary>
        /// Encrypt the newly generated file key using the master key.
        /// </summary>
        /// <param name="unencryptedFileKey">The file key to encrypt.</param>
        /// <param name="masterKey">The key to use for encryption.</param>
        /// <returns>The encrypted key.</returns>
        private byte[] encryptFileKey(byte[] unencryptedFileKey, byte[] masterKey)
        {
            using (var aes = new AesManaged
            {
                Key = masterKey,
                Mode = CipherMode.ECB,
                Padding = PaddingMode.PKCS7,
                IV = fileKeyIV
            })
            {

                using (var encrypter = aes.CreateEncryptor())
                using (var cipherStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(cipherStream, encrypter, CryptoStreamMode.Write))
                    using (var binaryWriter = new BinaryWriter(cryptoStream))
                    {
                        //Encrypt Data
                        binaryWriter.Write(unencryptedFileKey);
                    }

                    return cipherStream.ToArray();
                }
            }
        }

        private byte[] decryptFileKey(byte[] encryptedFileKey, byte[] iv, byte[] decodedMasterKey)
        {
            using (var aes = new AesManaged
            {
                Key = decodedMasterKey,
                Mode = CipherMode.ECB,
                Padding = PaddingMode.PKCS7,
                IV = fileKeyIV,
            })
            {

                using (var decrypter = aes.CreateDecryptor())
                using (var cipherStream = new MemoryStream())
                {
                    using (var decrypterStream = new CryptoStream(cipherStream, decrypter, CryptoStreamMode.Write))
                    using (var binaryWriter = new BinaryWriter(decrypterStream))
                    {
                        //Decrypt data
                        binaryWriter.Write(encryptedFileKey);
                    }

                    return cipherStream.ToArray();
                }
            }
        }


        private CleanableCryptoStream CreateCryptoStream(
            MemoryStream targetStream,
            byte[] key,
            byte[] iv,
            bool encrypt,
            CipherMode mode,
            PaddingMode padding,
            bool generateIV)
        {

            // Encrypt file key
            using (var cipher = new AesManaged
            {
                Key = key,
                Mode = CipherMode.CBC,
                Padding = PaddingMode.PKCS7,
            })
            {
                if (encrypt && generateIV)
                {
                    cipher.GenerateIV();
                }
                else
                {
                    cipher.IV = iv;
                }
                
                var encrypter = encrypt ? cipher.CreateEncryptor() : cipher.CreateDecryptor();
                return new CleanableCryptoStream(targetStream, encrypter, CryptoStreamMode.Write, cipher.IV);

            }
        }
    }
}
