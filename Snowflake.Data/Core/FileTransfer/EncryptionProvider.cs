using System.IO;
using System;
using Snowflake.Data.Log;
using System.Security.Cryptography;
using System.Text;

namespace Snowflake.Data.Core.FileTransfer
{ 
    /// </summary>
    class EncryptionProvider
    {
        public class CleanableCryptoStream : CryptoStream
        {
            private ICryptoTransform _transform;

            /// <summary>
            /// The cryptoStream to write to.
            /// </summary>
            private readonly Stream _stream;

            /// <summary>
            /// The IV generated by the encrypter.
            /// </summary>
            public byte[] IV { get; }
            

            public CleanableCryptoStream(Stream targetStream, ICryptoTransform transform, CryptoStreamMode mode, byte[] iv)
            : base(targetStream, transform, mode)
            {
                _stream = targetStream;
                _transform = transform;
                IV = iv;
            }

            protected override void Dispose(bool disposing)
            {
                try
                {
                    base.Dispose(disposing);
                }
                catch (CryptographicException)
                {
                    // Make sure to close the inner stream even if closing the cryptoStream fail
                    //https://stackoverflow.com/questions/41230836/dispose-a-cryptostream-after-it-has-thrown-a-cryptographicexception
                    //https://stackoverflow.com/questions/37137536/c-sharp-encryption-system-security-cryptography-cryptographicexception-at-crypto
                    //https://stackoverflow.com/questions/45401733/disposing-cryptostream-vs-disposing-underlying-stream
                    if (disposing)
                    {
                        _stream.Dispose();
                    }
                }

                if (disposing)
                {
                    _transform?.Dispose();
                    _transform = null;
                }
            }
        }


        /// <summary>
        /// The logger.
        /// </summary>
        private static readonly SFLogger Logger = SFLoggerFactory.GetLogger<EncryptionProvider>();

        /// <summary>
        /// The file key IV.
        /// </summary>
        private static byte[] fileKeyIV = initializeFileKeyIV();

        /// <summary>
        /// Generate a random IV used for this Encryption provider.
        /// </summary>
        /// <returns></returns>
        static byte[] initializeFileKeyIV()
        {
            var random = new Random();
            byte[] iv = new byte[16];
            random.NextBytes(iv);

            return iv;
        }

        /// <summary>
        /// Encrypt data and write to the outStream.
        /// </summary>
        /// <param name="outStream">The output stream to write the encrypted data to.</param>
        /// <param name="queryStageMasterKeyBase64">The query stage master key, encoded in base64.</param>
        /// <param name="ivBase64">The IV used to encrypt, encoded in base64.</param>
        /// <param name="keyBase64">The encrypted file key, , encoded in base64.</param>
        /// <returns>A crypto stream able to encrypt the data written into it.</returns>
        public CleanableCryptoStream CreateEncryptionStream(
            Stream outStream,
            string queryStageMasterKeyBase64,
            out string ivBase64,
            out string keyBase64)
        {

            byte[] decodedMasterKey = Convert.FromBase64String(queryStageMasterKeyBase64);
            int masterKeySize = decodedMasterKey.Length;
            Logger.Debug($"Master key size : {masterKeySize}");

            // Generate file key
            var random = new Random();
            byte[] unencryptedFileKey = new byte[masterKeySize];
            random.NextBytes(unencryptedFileKey);

            // Encrypt file key
            byte[] encryptedFileKey = encryptFileKey(unencryptedFileKey, decodedMasterKey);
            keyBase64 = Convert.ToBase64String(encryptedFileKey);

            // Stream to encrypt data into
            CleanableCryptoStream cryptoStream = CreateCryptoStream(
                outStream,
                unencryptedFileKey,
                null,
                true,
                CipherMode.CBC,
                PaddingMode.PKCS7);
            ivBase64 = Convert.ToBase64String(cryptoStream.IV);            

            return cryptoStream;
        }

        /// <summary>
        /// Decrypt data will writing to the outStream.
        /// </summary>
        /// <param name="outStream">The output stream to write the decrypted data to.</param>
        /// <param name="queryStageMasterKeyBase64">The query stage master key, encoded in base64.</param>
        /// <param name="ivBase64">The IV used to encrypt, encoded in base64.</param>
        /// <param name="keyBase64">The encrypted file key, , encoded in base64.</param>
        /// <returns>A crypto stream able to encrypt the data written into it.</returns>
        public CleanableCryptoStream CreateDecryptionStream(
            Stream outStream,
            string queryStageMasterKeyBase64,
            string ivBase64,
            string keyBase64)
        {

            byte[] decodedMasterKey = Convert.FromBase64String(queryStageMasterKeyBase64);
            int masterKeySize = decodedMasterKey.Length;

            byte[] iv = Convert.FromBase64String(ivBase64);
            byte[] encryptedFileKey = Convert.FromBase64String(keyBase64);


            // Decrypt file key
            byte[] decryptedKey = decryptFileKey(encryptedFileKey, fileKeyIV, decodedMasterKey);

            //Stream to decrypt data into
            return CreateCryptoStream(
                outStream,
                decryptedKey,
                iv,
                false,
                CipherMode.CBC,
                PaddingMode.PKCS7);
        }

        /// <summary>
        /// Encrypt the newly generated file key using the master key.
        /// </summary>
        /// <param name="unencryptedFileKey">The file key to encrypt.</param>
        /// <param name="masterKey">The key to use for encryption.</param>
        /// <returns>The encrypted key.</returns>
        private byte[] encryptFileKey(byte[] unencryptedFileKey, byte[] masterKey)
        {
            using (var aes = new AesManaged
            {
                Key = masterKey,
                Mode = CipherMode.ECB,
                Padding = PaddingMode.PKCS7,
                IV = fileKeyIV
            })
            {

                using (var encrypter = aes.CreateEncryptor())
                using (var cipherStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(cipherStream, encrypter, CryptoStreamMode.Write))
                    using (var binaryWriter = new BinaryWriter(cryptoStream))
                    {
                        //Encrypt Data
                        binaryWriter.Write(unencryptedFileKey);
                    }

                    return cipherStream.ToArray();
                }
            }
        }

        /// <summary>
        /// Decrypt a file key using the master key.
        /// </summary>
        /// <param name="encryptedFileKey">The file key to decrypt.</param>
        /// <param name="iv">The IV used to encrypt.</param>
        /// <param name="decodedMasterKey">The key used to encrypt.</param>
        /// <returns></returns>
        private byte[] decryptFileKey(byte[] encryptedFileKey, byte[] iv, byte[] decodedMasterKey)
        {
            using (var aes = new AesManaged
            {
                Key = decodedMasterKey,
                Mode = CipherMode.ECB,
                Padding = PaddingMode.PKCS7,
                IV = fileKeyIV,
            })
            {

                using (var decrypter = aes.CreateDecryptor())
                using (var cipherStream = new MemoryStream())
                {
                    using (var decrypterStream = new CryptoStream(cipherStream, decrypter, CryptoStreamMode.Write))
                    using (var binaryWriter = new BinaryWriter(decrypterStream))
                    {
                        //Decrypt data
                        binaryWriter.Write(encryptedFileKey);
                    }

                    return cipherStream.ToArray();
                }
            }
        }
        /// <summary>
        /// Creates a new cryptostream, either for encrypting or for decrypting.
        /// </summary>
        /// <param name="targetStream">The stream to write to after encryption/decryption.</param>
        /// <param name="key">The encryption key.</param>
        /// <param name="iv">The encryption IV or null if it needs to be generated.</param>
        /// <param name="encrypt">Flag to know if an encrypting or decryption stream must be created.</param>
        /// <param name="mode">The encryption mode.</param>
        /// <param name="padding">The encryption padding.</param>
        /// <returns></returns>
        private CleanableCryptoStream CreateCryptoStream(
            Stream targetStream,
            byte[] key,
            byte[] iv,
            bool encrypt,
            CipherMode mode,
            PaddingMode padding)
        {

            // Encrypt file key
            using (var cipher = new AesManaged
            {
                Key = key,
                Mode = CipherMode.CBC,
                Padding = PaddingMode.PKCS7,
            })
            {
                if (encrypt && (null == iv))
                {
                    cipher.GenerateIV();
                }
                else
                {
                    cipher.IV = iv;
                }

                var encrypter = encrypt ? cipher.CreateEncryptor() : cipher.CreateDecryptor();
                return new CleanableCryptoStream(targetStream, encrypter, CryptoStreamMode.Write, cipher.IV);

            }
        }
    }
}